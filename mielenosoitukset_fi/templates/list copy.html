{% extends 'base.html' %}

{% block title %} {{ _('Tulevat mielenosoitukset') }} {% endblock %}

{% block meta %}
<!-- General Meta Tags -->
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="{{ _('Lista tulevista mielenosoituksista') }}" />
<meta name="keywords" content="mielenosoitus, tapahtuma, Helsinki" />
<meta name="author" content="Mielenosoitukset.fi" />
<meta name="robots" content="index, follow" />
{% endblock %}

{% block styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/toolbox.css') }}" />
<link rel="stylesheet" href="{{ url_for('static', filename='css/list.css') }}" />
<link rel="stylesheet" href="{{ url_for('static', filename='css/demo.css') }}" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css" />

<!-- moved styles from here to static/css/list_v2.css-->
 <link rel="stylesheet" href="{{ url_for('static', filename='css/v2/list.css') }}" />
<link rel="stylesheet" href="{{ url_for('static', filename='css/v2/demo_list.css') }}" />

 <style>


 </style>
{% endblock %}

{% block content %}
<script src="{{ url_for('static', filename='js/demo.js') }}" defer></script>
<script src="{{ url_for('static', filename='js/demo-card-render.js') }}" defer></script>

{% include "_modals/_demo-card-template.html" %}

<section class="hero">
  <!-- lets add hero here-->
  <div class="hero-content">
    <h1>{{ _('Tulevat mielenosoitukset') }}</h1>
    <p>{{ _('Löydä ja osallistu mielenosoituksiin ympäri Suomen. Selaa tulevia tapahtumia, etsi sijainnin tai aiheen mukaan ja vaikuta yhdessä muiden kanssa.') }}</p>
  </div>
</section>
<section class="main-content">

  <form method="GET" action="#" class="search-form" id="search-form">
    <input type="text" name="search" placeholder="{{ _('Hae mielenosoituksia...') }}"
      aria-label="{{ _('Hae mielenosoituksia') }}" />
    <input type="text" placeholder="{{ _('Kaupunki') }}" aria-label="{{ _('Kaupunki') }}" id="city_input" />
    <input type="hidden" name="city" id="city" />
    <div class="suggestions" id="city_suggestions"></div>
    <input type="text" name="location" placeholder="{{ _('Sijainti') }}" aria-label="{{ _('Sijainti') }}" />
    <div class="date-range">
      <input type="text" name="display_date_start" id="date_start" placeholder="{{ _('Alkupäivä (pp.mm.vvvv)') }}"
        aria-label="{{ _('Alkupäivä (pp.mm.vvvv)') }}" />
      <span>-</span>
      <input type="text" name="display_date_end" id="date_end" placeholder="{{ _('Loppupäivä (pp.mm.vvvv)') }}"
        aria-label="{{ _('Loppupäivä (pp.mm.vvvv)') }}" />
    </div>
    <div class="date-error" id="date-error">{{ _('Valitse kelvollinen päivämääräväli tulevaisuudesta') }}</div>
    <input type="hidden" name="date_start" id="iso_date_start">
    <input type="hidden" name="date_end" id="iso_date_end">
    <div class="filters" id="filters"></div>
    <button type="submit" class="button">{{ _('Hae') }}</button>
  </form>
<section class="section-card">
  <h2 class="section-title"><i class="fa-solid fa-calendar-days"></i>{{ _('Kaikki mielenosoitukset') }}</h2>

  <div id="demos-grid" class="demos-grid"></div>
  <button id="load-more-btn" class="button button-secondary" style="display:none;">
    {{ _('Näytä lisää') }}
  </button>

  <!-- navigation -->
  <nav class="pagination">
    <button id="prev-page" class="button button-secondary" style="display:none;">
      {{ _('Edellinen') }}
    </button>
    <button id="next-page" class="button button-secondary" style="display:none;">
      {{ _('Seuraava') }}
    </button>
  </nav>

 <!-- Empty State -->
<div id="no-results" class="no-results-card" style="display:none;">
  <div class="no-results-icon">
    <i class="fa-regular fa-calendar-xmark"></i>
  </div>
  <h3 class="no-results-title">{{ _('Ei löytynyt mielenosoituksia') }}</h3>
  <p class="no-results-text">{{ _('Tällä hetkellä ei ole mielenosoituksia. Tarkista myöhemmin.') }}</p>
  <div class="no-results-action">
    <a href="{{ url_for('submit') }}" class="button button-primary">
      <i class="fa-solid fa-plus"></i>{{ _('Ilmoita uusi mielenosoitus') }}
    </a>
  </div>
</div>

</section>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const grid = document.getElementById('demos-grid');
  const loadMoreBtn = document.getElementById('load-more-btn');
  const prevBtn = document.getElementById('prev-page');
  const nextBtn = document.getElementById('next-page');
  const searchForm = document.getElementById('search-form');
  const noResultsCard = document.getElementById('no-results');

  let extraParams = {}; // holds search/filter params
  let current_page = 1;
  let total_pages = Infinity;

  /**
   * Wrapper around loadDemos to maintain pagination state and UI.
   *
   * Expects loadDemos(page, append, params) to return a Promise that resolves to
   * an object with optional pagination meta, e.g.:
   * {
   *   items: [...],
   *   meta: { current_page: 1, total_pages: 5, per_page: 20, total: 95 }
   * }
   *
   * If loadDemos does not return meta, the wrapper will still call it and try
   * to update controls conservatively.
   */
  async function loadDemosWrapper(page = 1, append = false) {
    // UI: loading state
    if (!append) {
      grid.innerHTML = `<div class="loading-container"><div class="spinner"></div><p>Ladataan mielenosoituksia...</p></div>`;
    } else {
      loadMoreBtn.classList.add('loading');
      loadMoreBtn.disabled = true;
    }

    try {
      const result = await loadDemos(page, append, extraParams) || {};

      // Normalize meta
      const meta = result.meta || result.pagination || {};
      const items = Array.isArray(result.items) ? result.items : (result || {}).rows || [];

      // Update pagination state if available
      if (meta.current_page) current_page = meta.current_page;
      else current_page = page;

      if (meta.total_pages) total_pages = meta.total_pages;
      else if (meta.total && meta.per_page) total_pages = Math.ceil(meta.total / meta.per_page);

      // Fallback: if we received fewer items than expected and this was append,
      // assume we've reached the end.
      if (append && items.length === 0) {
        // no more items
        total_pages = current_page; // prevent further "next"
      }

      // If grid is empty after non-append load, show empty state
      const gridHasItems = grid.querySelector('.demo-card, .demo-row') !== null;
      if (!append && (!items || items.length === 0) && !gridHasItems) {
        noResultsCard.style.display = '';
      } else {
        noResultsCard.style.display = 'none';
      }

      // Update pagination controls
      prevBtn.style.display = current_page > 1 ? '' : 'none';
      nextBtn.style.display = current_page < total_pages ? '' : 'none';

      // Show/load-more button only when there are more pages ahead
      if (current_page < total_pages) {
        loadMoreBtn.style.display = '';
      } else {
        loadMoreBtn.style.display = 'none';
      }
    } catch (err) {
      // On error, hide controls and show a minimal message
      console.error('Error loading demos:', err);
      prevBtn.style.display = 'none';
      nextBtn.style.display = 'none';
      loadMoreBtn.style.display = 'none';
      noResultsCard.style.display = '';
      grid.innerHTML = `<div class="error">Virhe ladattaessa mielenosoituksia</div>`;
    } finally {
      loadMoreBtn.classList.remove('loading');
      loadMoreBtn.disabled = false;
    }
  }

  // Initial load
  loadDemosWrapper(1, false);

  // Search form submit
  searchForm.addEventListener('submit', e => {
    e.preventDefault();

    // Collect search/filter values
    const searchValue = searchForm.querySelector('input[name="search"]').value.trim();
    const cityValue = searchForm.querySelector('input[name="city"]').value.trim();
    const locationValue = searchForm.querySelector('input[name="location"]').value.trim();
    const dateStart = searchForm.querySelector('input[name="date_start"]').value;
    const dateEnd = searchForm.querySelector('input[name="date_end"]').value;

    // Build extraParams for API (use underscores for field names)
    extraParams = {};
    if (searchValue) extraParams.search = searchValue;
    if (cityValue) extraParams.city = cityValue;
    if (locationValue) extraParams.location = locationValue;
    if (dateStart) extraParams.date_start = dateStart;
    if (dateEnd) extraParams.date_end = dateEnd;

    // Reset to first page and reload (replace content)
    current_page = 1;
    loadDemosWrapper(1, false);
  });

  // Load more (append)
  loadMoreBtn.addEventListener('click', e => {
    e.preventDefault();
    if (current_page < total_pages) {
      loadDemosWrapper(current_page + 1, true);
    }
  });

  // Next page (replace content)
  nextBtn.addEventListener('click', e => {
    e.preventDefault();
    if (current_page < total_pages) {
      loadDemosWrapper(current_page + 1, false);
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  });

  // Previous page (replace content)
  prevBtn.addEventListener('click', e => {
    e.preventDefault();
    if (current_page > 1) {
      loadDemosWrapper(current_page - 1, false);
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  });

});
</script>

</section>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="{{ url_for('static', filename='js/date.js') }}"></script>
<script src="{{ url_for('static', filename='js/jQuery/jq.min.js') }}"></script>
<script>
const cityList = {{ city_list | tojson }};
</script>
<script>
/**
 * Fetches demonstration data from the API and renders cards or table rows.
 * Handles infinite scroll, search, and view toggling.
 */
document.addEventListener("DOMContentLoaded", function () {
  function isTodayDate(dateStr) {
    if (!dateStr) return false;
    const today = new Date();
    const [d, m, y] = dateStr.split(".");
    return (
      today.getDate() === parseInt(d, 10) &&
      today.getMonth() + 1 === parseInt(m, 10) &&
      today.getFullYear() === parseInt(y, 10)
    );
  }

    document.getElementById("search-form").addEventListener("submit", e => {
    e.preventDefault();
    setView(view);
  });

  // City autocomplete
  const cityInput = $("#city_input");
  const selectedCitiesInput = $("#city");
  const filters = $("#filters");
  const citySuggestions = $("#city_suggestions");

  cityInput.on("input", function () {
    const query = cityInput.val();
    if (query.length > 2) {
      const matchingCities = cityList.filter(city =>
        city.toLowerCase().includes(query.toLowerCase())
      );
      citySuggestions.empty();
      matchingCities.forEach(city => {
        $("<div>").addClass("suggestion-item").text(city)
          .appendTo(citySuggestions)
          .on("click", function (event) {
            event.stopPropagation();
            const selectedCity = city;
            citySuggestions.empty().removeClass("show");
            cityInput.val("");
            const currentCities = selectedCitiesInput.val()
              ? selectedCitiesInput.val().split(",")
              : [];
            if (!currentCities.includes(selectedCity)) {
              currentCities.push(selectedCity);
              selectedCitiesInput.val(currentCities.join(","));
              const filterDiv = $(`<div class="filter"><span>${_("Kaupunki")}: ${selectedCity}</span><a href="#" data-city="${selectedCity}"><i class="fas fa-times"></i></a></div>`);
              filters.append(filterDiv);
              filterDiv.find("a").on("click", function (event) {
                event.preventDefault();
                const cityToRemove = $(this).data("city");
                selectedCitiesInput.val(currentCities.filter(c => c !== cityToRemove).join(","));
                filterDiv.remove();
              });
            }
          });
      });
      citySuggestions.addClass("show");
    } else {
      citySuggestions.empty().removeClass("show");
    }
  });

  $(document).on("click", function (event) {
    if (!citySuggestions.is(event.target) && citySuggestions.has(event.target).length === 0) {
      citySuggestions.empty().removeClass("show");
    }
  });

  const dateConfig = {
    dateFormat: "d.m.Y",
    minDate: "today",
    allowInput: true,
    locale: {
      firstDayOfWeek: 1,
      weekdays: {
        shorthand: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
        longhand: ["Sunnuntai", "Maanantai", "Tiistai", "Keskiviikko", "Torstai", "Perjantai", "Lauantai"]
      },
      months: {
        shorthand: ["Tam", "Hel", "Maa", "Huh", "Tou", "Kes", "Hei", "Elo", "Syy", "Lok", "Mar", "Jou"],
        longhand: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"]
      }
    }
  };

  const startPicker = flatpickr("#date_start", {
    ...dateConfig,
    onChange: selectedDates => {
      if (selectedDates[0]) {
        endPicker.set("minDate", selectedDates[0]);
      }
    }
  });

  const endPicker = flatpickr("#date_end", {
    ...dateConfig,
    onChange: selectedDates => {
      if (selectedDates[0]) {
        startPicker.set("maxDate", selectedDates[0]);
      }
    }
  });

  setView(view);
});
</script>

{% endblock %}
